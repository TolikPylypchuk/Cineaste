@using System.Collections.Concurrent
@using ListItemModelSource = TaskCompletionSource<OffsettableData<ListItemModel>?>

@inherits StatefulComponent<ListPageState>

<div class="container">
    @if (this.State.Value.IsLoading)
    {
        <MudProgressCircular
            Indeterminate="true"
            Color="Color.Primary"
            Size="Size.Large"
            Class="loading-circle"
        />
    } else if (this.State.Value.Problem is not null)
    {
        <ApiProblemAlert
            Problem="@this.State.Value.Problem"
            Text="ListComponent.Problem.LoadingListFailed"
            TryAgain="@this.FetchList"
            Class="problem-alert"
        />
    } else
    {
        var selectedItem = this.State.Value.SelectedItem;

        <MudDataGrid
            @ref="this.DataGridRef"
            VirtualizeServerData="this.ServerDataFunc"
            SelectedItemChanged="@((ListItemModel item) => this.SelectItem(item))"
            RowClassFunc="@((item, index) => "list-row" + (item == selectedItem ? " selected-row" : ""))"
            RowStyleFunc="@((item, index) => $"--cell-color: {item.Color}")"
            SortMode="SortMode.None"
            Virtualize="true"
            FixedHeader="true"
            Height="100%"
            ItemSize="64"
            Dense="true"
            Hover="true"
            Class="list"
        >
            <Columns>
                <MudBlazor.PropertyColumn
                    Title="@this.Loc["ListComponent.List.Number"]"
                    Property="@(item => item.DisplayNumber)"
                    CellClass="cell-content number"
                />

                <MudBlazor.PropertyColumn
                    Title="@this.Loc["ListComponent.List.Title"]"
                    Property="@(item => item.Title)"
                    CellClass="cell-content title"
                />

                <MudBlazor.PropertyColumn
                    Title="@this.Loc["ListComponent.List.OriginalTitle"]"
                    Property="@(item => item.OriginalTitle)"
                    CellClass="cell-content title"
                />

                <MudBlazor.TemplateColumn Title="@this.Loc["ListComponent.List.Year"]" CellClass="cell-content year">
                    <CellTemplate>
                        @if (context.Item.StartYear == context.Item.EndYear)
                        {
                            @context.Item.StartYear
                        } else
                        {
                            @context.Item.StartYear
                            <br />
                            @context.Item.EndYear
                        }
                    </CellTemplate>
                </MudBlazor.TemplateColumn>
            </Columns>
            <RowLoadingContent>
                <tr class="mud-table-row">
                    <td class="mud-table-cell" colspan="4">
                        @this.Loc["ListComponent.List.Loading"]
                    </td>
                </tr>
            </RowLoadingContent>
        </MudDataGrid>
    }
</div>

@code {
    private readonly ConcurrentDictionary<CancellationToken, ListItemModelSource> dataSources = [];

    [Parameter]
    public EventCallback<ListItemModel> ItemSelected { get; set; }

    [Parameter]
    public required Action FetchList { get; set; }

    public required MudDataGrid<ListItemModel> DataGridRef { get; set; }

    protected override void OnInitialized()
    {
        this.SubscribeToAction<CloseItemAction>(async _ =>
        {
            await this.DataGridRef.SetSelectedItemAsync(null!);
            this.StateHasChanged();
        });

        this.SubscribeToAction<FetchListItemsResultAction>(result => result.Handle(
            onSuccess: data => this.TrySetResult(data, result.Token),
            onFailure: _ => this.TrySetResult(null, result.Token)));

        this.SubscribeToAction<AddMovieResultAction>(this.HandleAddedOrUpdatedItem);
        this.SubscribeToAction<AddSeriesResultAction>(this.HandleAddedOrUpdatedItem);
        this.SubscribeToAction<AddFranchiseResultAction>(this.HandleAddedOrUpdatedItem);

        this.SubscribeToAction<UpdateMovieResultAction>(this.HandleAddedOrUpdatedItem);
        this.SubscribeToAction<UpdateSeriesResultAction>(this.HandleAddedOrUpdatedItem);
        this.SubscribeToAction<UpdateFranchiseResultAction>(this.HandleAddedOrUpdatedItem);

        this.SubscribeToAction<RemoveMovieResultAction>(this.HandleRemovedItem);
        this.SubscribeToAction<RemoveSeriesResultAction>(this.HandleRemovedItem);
        this.SubscribeToAction<RemoveFranchiseResultAction>(this.HandleRemovedItem);

        base.OnInitialized();
    }

    private async Task<GridData<ListItemModel>> ServerDataFunc(
        GridStateVirtualize<ListItemModel> gridState,
        CancellationToken token)
    {
        var dataSource = new ListItemModelSource();
        this.dataSources.TryAdd(token, dataSource);

        this.Dispatcher.Dispatch(new FetchListItemsAction(gridState.StartIndex, gridState.Count, token));

        var data = await dataSource.Task;

        return data is not null
            ? new() { Items = data.Items, TotalItems = data.Metadata.TotalItems }
            : new() { Items = [], TotalItems = 0 };
    }

    private async Task SelectItem(ListItemModel item)
    {
        if (item != this.State.Value.SelectedItem)
        {
            await this.ItemSelected.InvokeAsync(item);
        }
    }

    private void TrySetResult(OffsettableData<ListItemModel>? data, CancellationToken token)
    {
        if (this.dataSources.TryRemove(token, out var dataSource))
        {
            dataSource.TrySetResult(data);
        }
    }

    private void HandleAddedOrUpdatedItem<T>(ResultAction<T> action) =>
        action.Handle(
            onSuccess: movie => this.ReloadList(),
            onFailure: _ => { });

    private void HandleRemovedItem(EmptyResultAction action) =>
        action.Handle(
            onSuccess: () => this.ReloadList(),
            onFailure: _ => { });

    private async void ReloadList()
    {
        await this.DataGridRef.ReloadServerData();
        this.StateHasChanged();
    }
}
